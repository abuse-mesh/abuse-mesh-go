// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internal/adminapi/adminapi.proto

/*
Package adminapi is a generated protocol buffer package.

It is generated from these files:
	internal/adminapi/adminapi.proto

It has these top-level messages:
	GetNodeRequest
	GetClientsRequest
	GetServersRequest
	GetClientsResponse
	GetServersResponse
	Client
	Server
*/
package adminapi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import abusemesh "github.com/abuse-mesh/abuse-mesh-go-stubs/abusemesh"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The state the server assigned to the session with a client
type ClientSessionState int32

const (
	ClientSessionState_ClientSessionIdle        ClientSessionState = 0
	ClientSessionState_ClientSessionEstablished ClientSessionState = 1
	ClientSessionState_ClientSessionInterrupted ClientSessionState = 2
)

var ClientSessionState_name = map[int32]string{
	0: "ClientSessionIdle",
	1: "ClientSessionEstablished",
	2: "ClientSessionInterrupted",
}
var ClientSessionState_value = map[string]int32{
	"ClientSessionIdle":        0,
	"ClientSessionEstablished": 1,
	"ClientSessionInterrupted": 2,
}

func (x ClientSessionState) String() string {
	return proto.EnumName(ClientSessionState_name, int32(x))
}
func (ClientSessionState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The state the server assigned to the session with a client
type ServerSessionState int32

const (
	ServerSessionState_ServerSessionIdle        ServerSessionState = 0
	ServerSessionState_ServerSessionEstablished ServerSessionState = 1
	ServerSessionState_ServerSessionConnecting  ServerSessionState = 2
	ServerSessionState_ServerSessionInterrupted ServerSessionState = 3
)

var ServerSessionState_name = map[int32]string{
	0: "ServerSessionIdle",
	1: "ServerSessionEstablished",
	2: "ServerSessionConnecting",
	3: "ServerSessionInterrupted",
}
var ServerSessionState_value = map[string]int32{
	"ServerSessionIdle":        0,
	"ServerSessionEstablished": 1,
	"ServerSessionConnecting":  2,
	"ServerSessionInterrupted": 3,
}

func (x ServerSessionState) String() string {
	return proto.EnumName(ServerSessionState_name, int32(x))
}
func (ServerSessionState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type GetNodeRequest struct {
}

func (m *GetNodeRequest) Reset()                    { *m = GetNodeRequest{} }
func (m *GetNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodeRequest) ProtoMessage()               {}
func (*GetNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type GetClientsRequest struct {
}

func (m *GetClientsRequest) Reset()                    { *m = GetClientsRequest{} }
func (m *GetClientsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetClientsRequest) ProtoMessage()               {}
func (*GetClientsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type GetServersRequest struct {
}

func (m *GetServersRequest) Reset()                    { *m = GetServersRequest{} }
func (m *GetServersRequest) String() string            { return proto.CompactTextString(m) }
func (*GetServersRequest) ProtoMessage()               {}
func (*GetServersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type GetClientsResponse struct {
	Client []*Client `protobuf:"bytes,1,rep,name=client" json:"client,omitempty"`
}

func (m *GetClientsResponse) Reset()                    { *m = GetClientsResponse{} }
func (m *GetClientsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetClientsResponse) ProtoMessage()               {}
func (*GetClientsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetClientsResponse) GetClient() []*Client {
	if m != nil {
		return m.Client
	}
	return nil
}

type GetServersResponse struct {
	Client []*Client `protobuf:"bytes,1,rep,name=client" json:"client,omitempty"`
}

func (m *GetServersResponse) Reset()                    { *m = GetServersResponse{} }
func (m *GetServersResponse) String() string            { return proto.CompactTextString(m) }
func (*GetServersResponse) ProtoMessage()               {}
func (*GetServersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetServersResponse) GetClient() []*Client {
	if m != nil {
		return m.Client
	}
	return nil
}

type Client struct {
	// The id of the client node
	NodeId *abusemesh.UUID `protobuf:"bytes,1,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The id of this session
	SessionId *abusemesh.UUID `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	// If true the server wants to connect with the client
	// If false no session will be accepted
	ServerActive bool `protobuf:"varint,3,opt,name=server_active,json=serverActive" json:"server_active,omitempty"`
	// The current state of the connection
	State ClientSessionState `protobuf:"varint,4,opt,name=state,enum=adminapi.ClientSessionState" json:"state,omitempty"`
	// The count of events sent to the client
	EventCount uint64 `protobuf:"varint,5,opt,name=event_count,json=eventCount" json:"event_count,omitempty"`
}

func (m *Client) Reset()                    { *m = Client{} }
func (m *Client) String() string            { return proto.CompactTextString(m) }
func (*Client) ProtoMessage()               {}
func (*Client) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Client) GetNodeId() *abusemesh.UUID {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *Client) GetSessionId() *abusemesh.UUID {
	if m != nil {
		return m.SessionId
	}
	return nil
}

func (m *Client) GetServerActive() bool {
	if m != nil {
		return m.ServerActive
	}
	return false
}

func (m *Client) GetState() ClientSessionState {
	if m != nil {
		return m.State
	}
	return ClientSessionState_ClientSessionIdle
}

func (m *Client) GetEventCount() uint64 {
	if m != nil {
		return m.EventCount
	}
	return 0
}

type Server struct {
	// The id of the server node
	NodeId *abusemesh.UUID `protobuf:"bytes,1,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The id of this session
	SessionId *abusemesh.UUID `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	// If true the we are trying to connect to the server
	// If false no connection attempts will be made
	ClientActive bool `protobuf:"varint,3,opt,name=client_active,json=clientActive" json:"client_active,omitempty"`
	// The current state of the connection
	State ServerSessionState `protobuf:"varint,4,opt,name=state,enum=adminapi.ServerSessionState" json:"state,omitempty"`
	// The count of events received by the server
	EventCount uint64 `protobuf:"varint,5,opt,name=event_count,json=eventCount" json:"event_count,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Server) GetNodeId() *abusemesh.UUID {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *Server) GetSessionId() *abusemesh.UUID {
	if m != nil {
		return m.SessionId
	}
	return nil
}

func (m *Server) GetClientActive() bool {
	if m != nil {
		return m.ClientActive
	}
	return false
}

func (m *Server) GetState() ServerSessionState {
	if m != nil {
		return m.State
	}
	return ServerSessionState_ServerSessionIdle
}

func (m *Server) GetEventCount() uint64 {
	if m != nil {
		return m.EventCount
	}
	return 0
}

func init() {
	proto.RegisterType((*GetNodeRequest)(nil), "adminapi.GetNodeRequest")
	proto.RegisterType((*GetClientsRequest)(nil), "adminapi.GetClientsRequest")
	proto.RegisterType((*GetServersRequest)(nil), "adminapi.GetServersRequest")
	proto.RegisterType((*GetClientsResponse)(nil), "adminapi.GetClientsResponse")
	proto.RegisterType((*GetServersResponse)(nil), "adminapi.GetServersResponse")
	proto.RegisterType((*Client)(nil), "adminapi.Client")
	proto.RegisterType((*Server)(nil), "adminapi.Server")
	proto.RegisterEnum("adminapi.ClientSessionState", ClientSessionState_name, ClientSessionState_value)
	proto.RegisterEnum("adminapi.ServerSessionState", ServerSessionState_name, ServerSessionState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Admininterface service

type AdmininterfaceClient interface {
	// Returns the Node data of the current node
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*abusemesh.Node, error)
	// Returns all clients of this node
	GetClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error)
	// Returns all servers of this node
	GetServers(ctx context.Context, in *GetServersRequest, opts ...grpc.CallOption) (*GetServersResponse, error)
}

type admininterfaceClient struct {
	cc *grpc.ClientConn
}

func NewAdmininterfaceClient(cc *grpc.ClientConn) AdmininterfaceClient {
	return &admininterfaceClient{cc}
}

func (c *admininterfaceClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*abusemesh.Node, error) {
	out := new(abusemesh.Node)
	err := grpc.Invoke(ctx, "/adminapi.admininterface/GetNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *admininterfaceClient) GetClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error) {
	out := new(GetClientsResponse)
	err := grpc.Invoke(ctx, "/adminapi.admininterface/GetClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *admininterfaceClient) GetServers(ctx context.Context, in *GetServersRequest, opts ...grpc.CallOption) (*GetServersResponse, error) {
	out := new(GetServersResponse)
	err := grpc.Invoke(ctx, "/adminapi.admininterface/GetServers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Admininterface service

type AdmininterfaceServer interface {
	// Returns the Node data of the current node
	GetNode(context.Context, *GetNodeRequest) (*abusemesh.Node, error)
	// Returns all clients of this node
	GetClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error)
	// Returns all servers of this node
	GetServers(context.Context, *GetServersRequest) (*GetServersResponse, error)
}

func RegisterAdmininterfaceServer(s *grpc.Server, srv AdmininterfaceServer) {
	s.RegisterService(&_Admininterface_serviceDesc, srv)
}

func _Admininterface_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdmininterfaceServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/adminapi.admininterface/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdmininterfaceServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admininterface_GetClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdmininterfaceServer).GetClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/adminapi.admininterface/GetClients",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdmininterfaceServer).GetClients(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admininterface_GetServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdmininterfaceServer).GetServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/adminapi.admininterface/GetServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdmininterfaceServer).GetServers(ctx, req.(*GetServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Admininterface_serviceDesc = grpc.ServiceDesc{
	ServiceName: "adminapi.admininterface",
	HandlerType: (*AdmininterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNode",
			Handler:    _Admininterface_GetNode_Handler,
		},
		{
			MethodName: "GetClients",
			Handler:    _Admininterface_GetClients_Handler,
		},
		{
			MethodName: "GetServers",
			Handler:    _Admininterface_GetServers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/adminapi/adminapi.proto",
}

func init() { proto.RegisterFile("internal/adminapi/adminapi.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 469 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0x5f, 0x8b, 0xd3, 0x4c,
	0x14, 0xc6, 0xdf, 0x69, 0x77, 0xbb, 0xfb, 0x9e, 0x6a, 0xcd, 0x8e, 0x88, 0xa1, 0x5b, 0x30, 0xac,
	0x37, 0x61, 0x61, 0xb3, 0x10, 0xbd, 0x16, 0x96, 0x2a, 0x25, 0x37, 0x5e, 0xa4, 0xec, 0x75, 0x49,
	0x33, 0xc7, 0x76, 0x20, 0x99, 0xa9, 0x99, 0x49, 0x3f, 0x81, 0x1f, 0xd2, 0x0b, 0x3f, 0x8c, 0x64,
	0x26, 0xb6, 0x99, 0x74, 0x41, 0x14, 0xbc, 0x9b, 0xfe, 0xce, 0x73, 0xfe, 0x96, 0x27, 0x10, 0x70,
	0xa1, 0xb1, 0x12, 0x59, 0x71, 0x9f, 0xb1, 0x92, 0x8b, 0x6c, 0xc7, 0x0f, 0x8f, 0x68, 0x57, 0x49,
	0x2d, 0xe9, 0xe5, 0xaf, 0xdf, 0xd3, 0x87, 0x0d, 0xd7, 0xdb, 0x7a, 0x1d, 0xe5, 0xb2, 0xbc, 0xcf,
	0xd6, 0xb5, 0xc2, 0xbb, 0x12, 0xd5, 0xb6, 0xf3, 0xbc, 0x33, 0x19, 0xb9, 0x2c, 0xba, 0x2c, 0x97,
	0x65, 0x29, 0x85, 0x2d, 0x76, 0xe3, 0xc1, 0x64, 0x81, 0xfa, 0xb3, 0x64, 0x98, 0xe2, 0xd7, 0x1a,
	0x95, 0xbe, 0x79, 0x09, 0x57, 0x0b, 0xd4, 0xf3, 0x82, 0xa3, 0xd0, 0xca, 0x85, 0x4b, 0xac, 0xf6,
	0x58, 0x1d, 0xe0, 0x07, 0xa0, 0x5d, 0xa5, 0xda, 0x49, 0xa1, 0x90, 0x86, 0x30, 0xca, 0x0d, 0xf2,
	0x49, 0x30, 0x0c, 0xc7, 0xb1, 0x17, 0x1d, 0xe6, 0xb7, 0xd2, 0xb4, 0x8d, 0xb7, 0xf9, 0x87, 0xa2,
	0x7f, 0x9c, 0xff, 0x83, 0xc0, 0xc8, 0x22, 0x1a, 0xc2, 0x85, 0x90, 0x0c, 0x57, 0x9c, 0xf9, 0x24,
	0x20, 0xe1, 0x38, 0x7e, 0x11, 0x99, 0x8d, 0x9b, 0x85, 0xa3, 0xc7, 0xc7, 0xe4, 0x63, 0x3a, 0x6a,
	0xe2, 0x09, 0xa3, 0x11, 0x80, 0x42, 0xa5, 0xb8, 0x14, 0x8d, 0x78, 0xf0, 0xb4, 0xf8, 0xff, 0x56,
	0x92, 0x30, 0xfa, 0x16, 0x9e, 0x2b, 0x33, 0xe1, 0x2a, 0xcb, 0x35, 0xdf, 0xa3, 0x3f, 0x0c, 0x48,
	0x78, 0x99, 0x3e, 0xb3, 0xf0, 0xc1, 0x30, 0x1a, 0xc3, 0xb9, 0xd2, 0x99, 0x46, 0xff, 0x2c, 0x20,
	0xe1, 0x24, 0x9e, 0xf5, 0x47, 0x5e, 0xda, 0x72, 0xcb, 0x46, 0x93, 0x5a, 0x29, 0x7d, 0x03, 0x63,
	0xdc, 0xa3, 0xd0, 0xab, 0x5c, 0xd6, 0x42, 0xfb, 0xe7, 0x01, 0x09, 0xcf, 0x52, 0x30, 0x68, 0xde,
	0x10, 0xb3, 0x9e, 0x3d, 0xce, 0xbf, 0x5d, 0xcf, 0x5e, 0xb3, 0xb7, 0x9e, 0x85, 0xbf, 0x5d, 0xcf,
	0xce, 0xf7, 0x37, 0xeb, 0xdd, 0x6e, 0x80, 0x9e, 0x1e, 0x87, 0xbe, 0x82, 0x2b, 0x87, 0x26, 0xac,
	0x40, 0xef, 0x3f, 0x3a, 0x03, 0xdf, 0xc1, 0x9f, 0x94, 0xce, 0xd6, 0x05, 0x57, 0x5b, 0x64, 0x1e,
	0x39, 0x89, 0x26, 0x8d, 0x85, 0xaa, 0x7a, 0xa7, 0x91, 0x79, 0x83, 0xdb, 0x6f, 0x04, 0xe8, 0xe9,
	0x9c, 0x4d, 0x27, 0x87, 0x1e, 0x3b, 0x39, 0xd8, 0xed, 0x74, 0x0d, 0xaf, 0x9d, 0xe8, 0x5c, 0x0a,
	0x81, 0xb9, 0xe6, 0x62, 0xe3, 0x0d, 0x4e, 0x52, 0xbb, 0x63, 0x0c, 0xe3, 0xef, 0x04, 0x26, 0xe6,
	0x6e, 0xc6, 0xe0, 0x5f, 0xb2, 0x1c, 0xe9, 0x7b, 0xb8, 0x68, 0xcd, 0x47, 0xfd, 0xe3, 0x4d, 0x5d,
	0x3f, 0x4e, 0xbb, 0xff, 0x9e, 0x91, 0x2e, 0x00, 0x8e, 0xb6, 0xa3, 0xd7, 0x4e, 0xa2, 0x6b, 0xdb,
	0xe9, 0xec, 0xe9, 0x60, 0xeb, 0x34, 0x5b, 0xa8, 0xf5, 0x5f, 0xaf, 0x90, 0x6b, 0xf5, 0x5e, 0xa1,
	0x9e, 0x65, 0xd7, 0x23, 0xf3, 0x2d, 0x79, 0xf7, 0x33, 0x00, 0x00, 0xff, 0xff, 0x66, 0x6f, 0x97,
	0x9e, 0xbc, 0x04, 0x00, 0x00,
}
